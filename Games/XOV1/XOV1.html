<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>XO Online/Offline</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:#0b0f14; color:#e8eef6; min-height:100vh;
      display:flex; align-items:center; justify-content:center; padding:16px;
    }
    .app{
      width:min(980px, 100%); background:#101824; border:1px solid #223044;
      border-radius:16px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    header{
      padding:14px 16px; display:flex; gap:12px; align-items:center; justify-content:space-between;
      border-bottom:1px solid #223044; background:rgba(255,255,255,.02);
    }
    .brand{ font-weight:700; letter-spacing:.3px; }
    .row{ display:flex; gap:16px; padding:16px; flex-wrap:wrap; }
    .card{
      flex:1 1 300px; min-width:280px; background:#0e1622; border:1px solid #223044;
      border-radius:14px; padding:14px;
    }
    button{
      background:#1a2a3d; color:#e8eef6; border:1px solid #2a3f59;
      padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:600;
    }
    button:hover{ filter:brightness(1.07); }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .pill{ padding:7px 10px; border-radius:999px; font-size:13px; }
    .muted{ color:#9db0c7; font-size:13px; }
    .grid{
      display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; margin-top:12px;
      width:min(360px, 100%);
    }
    .cell{
      aspect-ratio:1/1; border:1px solid #2a3f59; border-radius:12px;
      display:grid; place-items:center; font-size:40px; font-weight:800;
      background:#0b111a; user-select:none;
    }
    .cell:hover{ filter:brightness(1.06); }
    .topline{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .list{ display:flex; flex-direction:column; gap:10px; margin-top:10px; }
    .item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px; border-radius:12px; border:1px solid #223044; background:#0b111a;
    }
    .badge{ font-size:12px; padding:3px 8px; border-radius:999px; border:1px solid #2a3f59; }
    .ok{ border-color:#2d5; }
    .warn{ border-color:#ea5; }
    .err{ border-color:#e55; }
    .hidden{ display:none !important; }
    .twoBtns{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    input{
      background:#0b111a; color:#e8eef6; border:1px solid #223044;
      padding:10px 12px; border-radius:12px; width:100%;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="brand">XO (Offline / Online)</div>
        <div class="muted" id="statusLine">Not signed in</div>
      </div>
      <div class="twoBtns">
        <button class="pill" id="btnBack" disabled>Back</button>
        <button class="pill" id="btnSignIn">Sign in</button>
        <button class="pill hidden" id="btnSignOut">Sign out</button>
      </div>
    </header>

    <!-- MAIN MENU -->
    <div class="row" id="viewMenu">
      <div class="card">
        <div class="topline">
          <div>
            <div style="font-weight:700;">Offline mode</div>
            <div class="muted">Two players on the same device</div>
          </div>
          <button id="startOffline">Start Offline</button>
        </div>
      </div>

      <div class="card">
        <div class="topline">
          <div>
            <div style="font-weight:700;">Online mode</div>
            <div class="muted">Invite an online friend and play</div>
          </div>
          <button id="startOnline">Start Online</button>
        </div>
        <div class="muted" style="margin-top:10px;">
          Online mode requires sign-in.
        </div>
      </div>
    </div>

    <!-- OFFLINE GAME -->
    <div class="row hidden" id="viewOffline">
      <div class="card">
        <div class="topline">
          <div>
            <div style="font-weight:700;">Offline Game</div>
            <div class="muted" id="offlineTurn">Turn: X</div>
          </div>
          <button id="offlineReset">Reset</button>
        </div>
        <div class="grid" id="offlineBoard"></div>
        <div class="muted" style="margin-top:10px;" id="offlineMsg"></div>
      </div>
    </div>

    <!-- ONLINE LOBBY -->
    <div class="row hidden" id="viewOnline">
      <div class="card">
        <div class="topline">
          <div>
            <div style="font-weight:700;">Online Lobby</div>
            <div class="muted">Friends online</div>
          </div>
          <span class="badge ok" id="presenceBadge">Offline</span>
        </div>

        <div style="margin-top:10px;">
          <label class="muted">Your display name</label>
          <input id="displayName" placeholder="Type your name (shown to friends)" />
          <div class="twoBtns" style="margin-top:10px;">
            <button id="saveName">Save</button>
          </div>
        </div>

        <div class="list" id="friendsList"></div>
      </div>

      <div class="card">
        <div class="topline">
          <div>
            <div style="font-weight:700;">Invites</div>
            <div class="muted">Incoming match requests</div>
          </div>
        </div>
        <div class="list" id="invitesList"></div>
      </div>
    </div>

    <!-- ONLINE GAME -->
    <div class="row hidden" id="viewRoom">
      <div class="card" style="flex: 2 1 420px;">
        <div class="topline">
          <div>
            <div style="font-weight:700;">Online Match</div>
            <div class="muted" id="roomLine">Room: —</div>
          </div>
          <div class="twoBtns">
            <button id="btnLeave" class="warn">Leave</button>
            <button id="btnRematch" disabled>Rematch</button>
          </div>
        </div>

        <div class="muted" style="margin-top:10px;" id="matchInfo">—</div>
        <div class="grid" id="onlineBoard"></div>
        <div class="muted" style="margin-top:10px;" id="matchMsg"></div>
      </div>

      <div class="card">
        <div style="font-weight:700;">Players</div>
        <div class="list" style="margin-top:10px;">
          <div class="item"><div id="pX">X: —</div><span class="badge" id="pXb">—</span></div>
          <div class="item"><div id="pO">O: —</div><span class="badge" id="pOb">—</span></div>
        </div>
        <div class="muted" style="margin-top:10px;">
          If a player disconnects, the match ends for both.
        </div>
      </div>
    </div>

  </div>

<script>
  window.xoAppInitialized = false;
</script>

<script type="module">
  window.xoAppInitialized = true;
  // Firebase v10+ modules
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
  import {
    getDatabase, ref, set, get, update, push, onValue, onChildAdded, onChildChanged,
    remove, serverTimestamp, onDisconnect, off
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";

  // TODO: Replace with your Firebase config
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_PROJECT.firebaseapp.com",
    databaseURL: "https://YOUR_PROJECT-default-rtdb.firebaseio.com",
    projectId: "YOUR_PROJECT_ID",
    appId: "YOUR_APP_ID"
  };

  let app = null;
  let auth = null;
  let db = null;
  let firebaseEnabled = true;
  try {
    app = initializeApp(firebaseConfig);
    auth = getAuth(app);
    db = getDatabase(app);
  } catch (e) {
    firebaseEnabled = false;
    console.warn("[Firebase disabled]", e);
  }

  // ---------- UI helpers ----------
  const $ = (id) => document.getElementById(id);
  const views = {
    menu: $("viewMenu"),
    offline: $("viewOffline"),
    online: $("viewOnline"),
    room: $("viewRoom")
  };
  function showView(name){
    for (const k of Object.keys(views)) views[k].classList.add("hidden");
    views[name].classList.remove("hidden");
    $("btnBack").disabled = (name === "menu");
  }

  function setStatus(text){ $("statusLine").textContent = text; }

  // ---------- Offline game ----------
  const offline = {
    board: Array(9).fill(""),
    turn: "X",
    ended: false
  };

  function winnerOf(board){
    const lines = [
      [0,1,2],[3,4,5],[6,7,8],
      [0,3,6],[1,4,7],[2,5,8],
      [0,4,8],[2,4,6]
    ];
    for (const [a,b,c] of lines){
      if (board[a] && board[a] === board[b] && board[a] === board[c]) return board[a];
    }
    if (board.every(v => v)) return "draw";
    return "";
  }

  function renderOffline(){
    $("offlineTurn").textContent = offline.ended ? "Game Over" : `Turn: ${offline.turn}`;
    const win = winnerOf(offline.board);
    $("offlineMsg").textContent =
      win === "draw" ? "Draw." : (win ? `${win} wins.` : "");
  }

  function buildBoard(container, onClick){
    container.innerHTML = "";
    for (let i=0;i<9;i++){
      const d = document.createElement("div");
      d.className = "cell";
      d.dataset.i = String(i);
      d.addEventListener("click", () => onClick(i));
      container.appendChild(d);
    }
  }

  buildBoard($("offlineBoard"), (i) => {
    if (offline.ended) return;
    if (offline.board[i]) return;
    offline.board[i] = offline.turn;
    const win = winnerOf(offline.board);
    if (win) offline.ended = true;
    offline.turn = offline.turn === "X" ? "O" : "X";
    // paint
    [...$("offlineBoard").children].forEach((c, idx) => c.textContent = offline.board[idx]);
    renderOffline();
  });

  $("offlineReset").addEventListener("click", () => {
    offline.board = Array(9).fill("");
    offline.turn = "X";
    offline.ended = false;
    [...$("offlineBoard").children].forEach(c => c.textContent = "");
    renderOffline();
  });

  // ---------- Online state ----------
  let me = null;              // { uid, name }
  let currentRoomId = null;
  let roomUnsubs = [];        // store off() callbacks references

  function randomRoomId(){
    // push().key gives nice unique IDs; we use that.
    return push(ref(db, "rooms")).key;
  }

  async function writePresenceOnline(uid, name){
    const statusRef = ref(db, `status/${uid}`);
    const connRef = ref(db, ".info/connected");

    onValue(connRef, async (snap) => {
      if (snap.val() !== true) return;

      // onDisconnect fires when client disconnects (tab closed, network lost).
      await onDisconnect(statusRef).set({
        online: false,
        name: name || "Player",
        lastSeen: serverTimestamp()
      });

      // set online now
      await set(statusRef, {
        online: true,
        name: name || "Player",
        lastSeen: serverTimestamp()
      });
    });
  }

  async function loadMyName(uid){
    const s = await get(ref(db, `status/${uid}/name`));
    return s.exists() ? s.val() : "";
  }

  // Render friends list from /friends/{me}/... and show only those who are online
  async function subscribeFriends(){
    const listEl = $("friendsList");
    listEl.innerHTML = `<div class="muted">Loading friends…</div>`;

    const friendsRef = ref(db, `friends/${me.uid}`);
    onValue(friendsRef, async (snap) => {
      const friendsObj = snap.val() || {};
      const friendUids = Object.keys(friendsObj);
      if (!friendUids.length){
        listEl.innerHTML = `<div class="muted">No friends added yet. Add UIDs under friends/${me.uid}/ in the database.</div>`;
        return;
      }

      // fetch each friend's status
      const rows = [];
      for (const fuid of friendUids){
        const st = await get(ref(db, `status/${fuid}`));
        const val = st.val();
        const online = !!(val && val.online);
        rows.push({ uid: fuid, name: val?.name || fuid.slice(0,6), online });
      }

      // build UI
      listEl.innerHTML = "";
      rows.sort((a,b) => Number(b.online)-Number(a.online) || a.name.localeCompare(b.name));
      for (const r of rows){
        const item = document.createElement("div");
        item.className = "item";
        const left = document.createElement("div");
        left.innerHTML = `<div style="font-weight:700;">${escapeHtml(r.name)}</div>
                          <div class="muted">${r.uid}</div>`;
        const right = document.createElement("div");
        right.className = "twoBtns";

        const badge = document.createElement("span");
        badge.className = `badge ${r.online ? "ok" : "err"}`;
        badge.textContent = r.online ? "Online" : "Offline";

        const btn = document.createElement("button");
        btn.textContent = "Invite";
        btn.disabled = !r.online || !!currentRoomId;
        btn.addEventListener("click", () => sendInvite(r.uid, r.name));

        right.appendChild(badge);
        right.appendChild(btn);

        item.appendChild(left);
        item.appendChild(right);
        listEl.appendChild(item);
      }
    });
  }

  function escapeHtml(s){
    return (s||"").replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  async function sendInvite(toUid, toName){
    if (!me) return;
    const roomId = randomRoomId();
    const inviteRef = push(ref(db, `invites/${toUid}`));
    await set(inviteRef, {
      fromUid: me.uid,
      fromName: me.name || "Player",
      status: "pending",
      roomId,
      createdAt: Date.now()
    });
    alert(`Invite sent to ${toName}.`);
  }

  function subscribeInvites(){
    const listEl = $("invitesList");
    listEl.innerHTML = `<div class="muted">Waiting for invites…</div>`;

    const invRef = ref(db, `invites/${me.uid}`);

    // live updates
    onValue(invRef, (snap) => {
      const obj = snap.val() || {};
      const invites = Object.entries(obj).map(([id, v]) => ({ id, ...v }))
        .filter(x => x.status === "pending")
        .sort((a,b) => (b.createdAt||0)-(a.createdAt||0));

      if (!invites.length){
        listEl.innerHTML = `<div class="muted">No incoming invites.</div>`;
        return;
      }

      listEl.innerHTML = "";
      for (const inv of invites){
        const item = document.createElement("div");
        item.className = "item";
        const left = document.createElement("div");
        left.innerHTML = `<div style="font-weight:700;">${escapeHtml(inv.fromName || "Friend")}</div>
                          <div class="muted">${inv.fromUid}</div>`;
        const right = document.createElement("div");
        right.className = "twoBtns";

        const accept = document.createElement("button");
        accept.textContent = "Accept";
        accept.addEventListener("click", () => acceptInvite(inv));

        const reject = document.createElement("button");
        reject.textContent = "Reject";
        reject.addEventListener("click", () => rejectInvite(inv));

        right.appendChild(accept);
        right.appendChild(reject);

        item.appendChild(left);
        item.appendChild(right);
        listEl.appendChild(item);
      }
    });
  }

  async function acceptInvite(inv){
    // mark invite accepted
    await update(ref(db, `invites/${me.uid}/${inv.id}`), { status: "accepted" });

    // create room as the acceptor (host sets room state)
    // We'll assign: inviter = X, acceptor = O (simple rule)
    const roomId = inv.roomId;
    const roomRef = ref(db, `rooms/${roomId}`);

    const room = {
      status: "playing",
      board: Array(9).fill(""),
      turn: "X",
      winner: "",
      lastMoveAt: Date.now(),
      players: { X: inv.fromUid, O: me.uid },
      names: {
        [inv.fromUid]: inv.fromName || "Player X",
        [me.uid]: me.name || "Player O"
      }
    };

    await set(roomRef, room);

    // notify inviter by writing invite result back for them (optional)
    // simplest: inviter watches sent invite by ID? Not stored. So we rely on room existence.
    // Move both into room view:
    joinRoom(roomId);
  }

  async function rejectInvite(inv){
    await update(ref(db, `invites/${me.uid}/${inv.id}`), { status: "rejected" });
  }

  // inviter side: after sending invite, they don't know acceptance yet.
  // simplest rule: inviter can "poll" roomId existence (or you can store sent invites under /sentInvites/{from}/)
  // We'll implement: when online lobby opens, we listen for rooms where I'm a player (light approach is hard).
  // For now: if you sent invite, tell your friend to accept; inviter can also accept by entering room when created.
  // We'll implement quick helper: "watch for rooms created with me as X or O" is not index-friendly; keep it simple:
  // When you send invite, store the roomId locally and wait until /rooms/roomId appears.
  let pendingRoomWatch = null;

  async function watchRoomCreation(roomId){
    if (pendingRoomWatch) pendingRoomWatch();
    const roomRef = ref(db, `rooms/${roomId}`);
    const cb = onValue(roomRef, (snap) => {
      if (snap.exists() && snap.val().status === "playing"){
        // room created by acceptor -> join
        if (pendingRoomWatch) pendingRoomWatch();
        joinRoom(roomId);
      }
    });
    pendingRoomWatch = () => off(roomRef, "value", cb);
    alert("Waiting for friend to accept… Keep this page open.");
  }

  // Modify sendInvite to also wait:
  async function sendInvite(toUid, toName){
    if (!me) return;
    const roomId = randomRoomId();
    const inviteRef = push(ref(db, `invites/${toUid}`));
    await set(inviteRef, {
      fromUid: me.uid,
      fromName: me.name || "Player",
      status: "pending",
      roomId,
      createdAt: Date.now()
    });
    await watchRoomCreation(roomId);
    // Note: if rejected, inviter won’t see it in this simplified model.
    // Production version should also write /sentInvites/{fromUid}/{inviteId}.
  }

  // ---------- Room logic ----------
  function clearRoomSubscriptions(){
    for (const u of roomUnsubs) u();
    roomUnsubs = [];
  }

  function subscribe(refPath, event, handler){
    const r = ref(db, refPath);
    if (event === "value"){
      const cb = onValue(r, handler);
      roomUnsubs.push(() => off(r, "value", cb));
    }
  }

  async function joinRoom(roomId){
    currentRoomId = roomId;
    showView("room");
    $("roomLine").textContent = `Room: ${roomId}`;
    $("btnRematch").disabled = true;
    $("matchMsg").textContent = "";

    clearRoomSubscriptions();

    const roomRefPath = `rooms/${roomId}`;

    subscribe(roomRefPath, "value", async (snap) => {
      if (!snap.exists()){
        $("matchMsg").textContent = "Room ended.";
        $("btnRematch").disabled = true;
        return;
      }

      const room = snap.val();
      const board = room.board || Array(9).fill("");
      const turn = room.turn || "X";
      const winner = room.winner || "";
      const status = room.status || "playing";
      const players = room.players || {};
      const names = room.names || {};

      // Identify my symbol
      const mySymbol = (players.X === me.uid) ? "X" : (players.O === me.uid ? "O" : "");
      const oppUid = (mySymbol === "X") ? players.O : players.X;

      $("matchInfo").textContent =
        status === "ended" ? "Match ended." :
        winner === "draw" ? "Draw." :
        winner ? `${winner} wins.` :
        `Turn: ${turn} — You are ${mySymbol || "?"}`;

      // Render board
      [...$("onlineBoard").children].forEach((c, idx) => c.textContent = board[idx] || "");

      // Players panel
      $("pX").textContent = `X: ${names[players.X] || players.X || "—"}`;
      $("pO").textContent = `O: ${names[players.O] || players.O || "—"}`;

      // Check opponent presence
      if (oppUid){
        const oppSnap = await get(ref(db, `status/${oppUid}`));
        const oppOnline = !!(oppSnap.val() && oppSnap.val().online);
        $("pXb").textContent = (players.X === me.uid ? "You" : (oppOnline ? "Online" : "Offline"));
        $("pOb").textContent = (players.O === me.uid ? "You" : (oppOnline ? "Online" : "Offline"));

        // If opponent offline and match still playing => end it
        if (!oppOnline && status === "playing"){
          await update(ref(db, roomRefPath), {
            status: "ended",
            winner: "",
            endedReason: `Opponent disconnected`,
            endedAt: Date.now()
          });
          $("matchMsg").textContent = `${names[oppUid] || "Friend"} disconnected.`;
        }
      }

      // Enable rematch button if ended
      $("btnRematch").disabled = (status !== "ended");
    });

    // Build board clicks (only once)
    if (!$("onlineBoard").children.length){
      buildBoard($("onlineBoard"), (i) => tryMove(i));
    }
  }

  async function tryMove(i){
    if (!currentRoomId || !me) return;
    const roomPath = `rooms/${currentRoomId}`;
    const snap = await get(ref(db, roomPath));
    if (!snap.exists()) return;

    const room = snap.val();
    if (room.status !== "playing") return;

    const players = room.players || {};
    const mySymbol = (players.X === me.uid) ? "X" : (players.O === me.uid ? "O" : "");
    if (!mySymbol) return;

    if (room.turn !== mySymbol) return;
    const board = room.board || Array(9).fill("");
    if (board[i]) return;

    board[i] = mySymbol;

    const w = winnerOf(board);
    const updates = {
      board,
      lastMoveAt: Date.now(),
      turn: (mySymbol === "X" ? "O" : "X")
    };

    if (w){
      updates.status = "ended";
      updates.winner = w;
      updates.endedAt = Date.now();
    }

    await update(ref(db, roomPath), updates);
  }

  $("btnLeave").addEventListener("click", async () => {
    if (!currentRoomId) { showView("online"); return; }
    const roomPath = `rooms/${currentRoomId}`;
    const snap = await get(ref(db, roomPath));
    if (snap.exists()){
      const room = snap.val();
      const names = room.names || {};
      await update(ref(db, roomPath), {
        status: "ended",
        winner: "",
        endedReason: `${names[me.uid] || "Player"} left`,
        endedAt: Date.now()
      });
    }
    clearRoomSubscriptions();
    currentRoomId = null;
    showView("online");
  });

  $("btnRematch").addEventListener("click", async () => {
    if (!currentRoomId || !me) return;
    const rPath = `rooms/${currentRoomId}`;
    await set(ref(db, `${rPath}/rematch/${me.uid}`), true);

    const snap = await get(ref(db, rPath));
    if (!snap.exists()) return;
    const room = snap.val();
    const players = room.players || {};
    const a = players.X, b = players.O;

    // if both voted rematch -> reset
    const rem = (await get(ref(db, `${rPath}/rematch`))).val() || {};
    if (rem[a] && rem[b]){
      await update(ref(db, rPath), {
        status: "playing",
        board: Array(9).fill(""),
        turn: "X",
        winner: "",
        lastMoveAt: Date.now()
      });
      await remove(ref(db, `${rPath}/rematch`));
      $("matchMsg").textContent = "Rematch started.";
    } else {
      $("matchMsg").textContent = "Rematch requested. Waiting for friend…";
    }
  });

  // ---------- Navigation ----------
  $("btnBack").addEventListener("click", () => {
    if (views.room && !views.room.classList.contains("hidden")){
      // leaving room goes through leave handler
      $("btnLeave").click();
      return;
    }
    showView("menu");
  });

  $("startOffline").addEventListener("click", () => {
    showView("offline");
    $("offlineReset").click();
  });

  $("startOnline").addEventListener("click", async () => {
    if (!firebaseEnabled){
      alert("Online mode is unavailable. Firebase is not configured.");
      return;
    }
    if (!me){
      alert("Please sign in first to use Online mode.");
      return;
    }
    showView("online");
    $("presenceBadge").textContent = "Online";
    $("presenceBadge").className = "badge ok";
  });

  // ---------- Name handling ----------
  $("saveName").addEventListener("click", async () => {
    if (!me) return;
    const name = $("displayName").value.trim().slice(0, 24);
    me.name = name || me.name || "Player";
    await update(ref(db, `status/${me.uid}`), { name: me.name });
    setStatus(`Signed in as ${me.name}`);
    alert("Name saved.");
  });

  // ---------- Auth ----------
  $("btnSignIn").addEventListener("click", async () => {
    if (!firebaseEnabled) return;
    const provider = new GoogleAuthProvider();
    await signInWithPopup(auth, provider);
  });

  $("btnSignOut").addEventListener("click", async () => {
    if (!firebaseEnabled) return;
    await signOut(auth);
  });

  if (firebaseEnabled){
    onAuthStateChanged(auth, async (user) => {
    clearRoomSubscriptions();
    currentRoomId = null;

    if (!user){
      me = null;
      setStatus("Not signed in");
      $("btnSignIn").classList.remove("hidden");
      $("btnSignOut").classList.add("hidden");
      $("presenceBadge").textContent = "Offline";
      $("presenceBadge").className = "badge err";
      showView("menu");
      return;
    }

    me = { uid: user.uid, name: user.displayName || "Player" };

    // Load saved name if exists
    const saved = await loadMyName(me.uid);
    if (saved) me.name = saved;

    $("displayName").value = me.name;
    setStatus(`Signed in as ${me.name}`);
    $("btnSignIn").classList.add("hidden");
    $("btnSignOut").classList.remove("hidden");

    // Presence
    await writePresenceOnline(me.uid, me.name);
    $("presenceBadge").textContent = "Online";
    $("presenceBadge").className = "badge ok";

    // Lobby subscriptions
    await subscribeFriends();
    subscribeInvites();
    });
  } else {
    $("btnSignIn").disabled = true;
    $("btnSignOut").classList.add("hidden");
    $("presenceBadge").textContent = "Offline";
    $("presenceBadge").className = "badge err";
    setStatus("Offline mode only (Firebase not configured)");
  }

  // Build online board cells
  buildBoard($("onlineBoard"), (i) => tryMove(i));
  // Initial view
  showView("menu");
</script>

<script>
  window.addEventListener("DOMContentLoaded", () => {
    if (window.xoAppInitialized) return;

    const $ = (id) => document.getElementById(id);
    const views = {
      menu: $("viewMenu"),
      offline: $("viewOffline"),
      online: $("viewOnline"),
      room: $("viewRoom")
    };
    function showView(name){
      for (const k of Object.keys(views)) views[k].classList.add("hidden");
      views[name].classList.remove("hidden");
      $("btnBack").disabled = (name === "menu");
    }
    function setStatus(text){ $("statusLine").textContent = text; }

    const offline = {
      board: Array(9).fill(""),
      turn: "X",
      ended: false
    };

    function winnerOf(board){
      const lines = [
        [0,1,2],[3,4,5],[6,7,8],
        [0,3,6],[1,4,7],[2,5,8],
        [0,4,8],[2,4,6]
      ];
      for (const [a,b,c] of lines){
        if (board[a] && board[a] === board[b] && board[a] === board[c]) return board[a];
      }
      if (board.every(v => v)) return "draw";
      return "";
    }

    function renderOffline(){
      $("offlineTurn").textContent = offline.ended ? "Game Over" : `Turn: ${offline.turn}`;
      const win = winnerOf(offline.board);
      $("offlineMsg").textContent =
        win === "draw" ? "Draw." : (win ? `${win} wins.` : "");
    }

    function buildBoard(container, onClick){
      container.innerHTML = "";
      for (let i=0;i<9;i++){
        const d = document.createElement("div");
        d.className = "cell";
        d.dataset.i = String(i);
        d.addEventListener("click", () => onClick(i));
        container.appendChild(d);
      }
    }

    buildBoard($("offlineBoard"), (i) => {
      if (offline.ended) return;
      if (offline.board[i]) return;
      offline.board[i] = offline.turn;
      const win = winnerOf(offline.board);
      if (win) offline.ended = true;
      offline.turn = offline.turn === "X" ? "O" : "X";
      [...$("offlineBoard").children].forEach((c, idx) => c.textContent = offline.board[idx]);
      renderOffline();
    });

    $("offlineReset").addEventListener("click", () => {
      offline.board = Array(9).fill("");
      offline.turn = "X";
      offline.ended = false;
      [...$("offlineBoard").children].forEach(c => c.textContent = "");
      renderOffline();
    });

    $("startOffline").addEventListener("click", () => {
      showView("offline");
      $("offlineReset").click();
    });

    $("btnBack").addEventListener("click", () => showView("menu"));

    $("btnSignIn").disabled = true;
    $("btnSignOut").classList.add("hidden");
    $("startOnline").disabled = true;
    const badge = $("presenceBadge");
    if (badge){
      badge.textContent = "Offline";
      badge.className = "badge err";
    }
    setStatus("Offline mode only");
    showView("menu");
  });
</script>
</body>
</html>
